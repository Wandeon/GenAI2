# Sprint 0.2: Discovery + Real Feeds Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Connect real data sources (HN, GitHub, Papers) and implement search.

**Architecture:** Feed processors fetch from external APIs, normalize to Event shape, serve via tRPC. Search uses PostgreSQL FTS on mock data first, real data after feeds are wired.

**Tech Stack:** Next.js 16, tRPC, Zod, node-fetch

---

## Sprint Scope

**IN SCOPE:**
- Search bar with instant results
- HN feed integration
- GitHub feed integration
- Papers feed integration

**OUT OF SCOPE:**
- Time Machine filtering (Sprint 0.3)
- Context panel details (Sprint 0.4)
- Mobile layout (Sprint 0.4)
- Evidence snapshots (Phase 1)
- Pipeline processors (Phase 2)

---

## Task 1: Search Router + UI

**Files:**
- Create: `packages/trpc/src/routers/search.ts`
- Modify: `packages/trpc/src/root.ts`
- Modify: `apps/web/src/components/layout/header.tsx`

### Step 1: Create search router

```typescript
// packages/trpc/src/routers/search.ts
import { z } from "zod";
import { router, publicProcedure } from "../trpc";

// Unified search result shape
const SearchResultSchema = z.object({
  id: z.string(),
  type: z.enum(["event", "entity", "topic"]),
  title: z.string(),
  titleHr: z.string().optional(),
  snippet: z.string().optional(),
  occurredAt: z.date().optional(),
  impactLevel: z.enum(["BREAKING", "HIGH", "MEDIUM", "LOW"]).optional(),
});

export type SearchResult = z.infer<typeof SearchResultSchema>;

export const searchRouter = router({
  instant: publicProcedure
    .input(
      z.object({
        query: z.string().min(1).max(100),
        limit: z.number().min(1).max(20).default(10),
      })
    )
    .query(async ({ input }) => {
      const q = input.query.toLowerCase();

      // Search mock events (will be replaced with FTS in Phase 1)
      const mockEvents = [
        {
          id: "1",
          title: "OpenAI announces GPT-5",
          titleHr: "OpenAI najavljuje GPT-5",
          occurredAt: new Date(),
          impactLevel: "BREAKING" as const,
        },
        {
          id: "2",
          title: "Anthropic raises $2B",
          titleHr: "Anthropic prikupio 2 milijarde",
          occurredAt: new Date(),
          impactLevel: "HIGH" as const,
        },
      ];

      const results: SearchResult[] = mockEvents
        .filter(
          (e) =>
            e.title.toLowerCase().includes(q) ||
            e.titleHr?.toLowerCase().includes(q)
        )
        .slice(0, input.limit)
        .map((e) => ({
          id: e.id,
          type: "event" as const,
          title: e.title,
          titleHr: e.titleHr,
          occurredAt: e.occurredAt,
          impactLevel: e.impactLevel,
        }));

      return { results, total: results.length };
    }),
});
```

### Step 2: Add search router to root

```typescript
// packages/trpc/src/root.ts
import { router } from "./trpc";
import { eventsRouter } from "./routers/events";
import { entitiesRouter } from "./routers/entities";
import { topicsRouter } from "./routers/topics";
import { searchRouter } from "./routers/search";

export const appRouter = router({
  events: eventsRouter,
  entities: entitiesRouter,
  topics: topicsRouter,
  search: searchRouter,
});

export type AppRouter = typeof appRouter;
```

### Step 3: Add search dropdown to header

Update `apps/web/src/components/layout/header.tsx` to show search results dropdown when typing.

### Step 4: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(search): add instant search router and UI`

---

## Task 2: Feed Types + Shared Schema

**Files:**
- Create: `packages/shared/src/types/feeds.ts`
- Modify: `packages/shared/src/index.ts`

### Step 1: Create feed types

```typescript
// packages/shared/src/types/feeds.ts
import { z } from "zod";

// Raw feed item from external source
export const RawFeedItemSchema = z.object({
  sourceType: z.enum(["HN", "GITHUB", "ARXIV"]),
  externalId: z.string(),
  url: z.string().url(),
  title: z.string(),
  author: z.string().optional(),
  publishedAt: z.date(),
  score: z.number().optional(),
  commentCount: z.number().optional(),
  tags: z.array(z.string()).optional(),
});

export type RawFeedItem = z.infer<typeof RawFeedItemSchema>;

// Normalized event for display
export const NormalizedEventSchema = z.object({
  id: z.string(),
  sourceType: z.enum(["HN", "GITHUB", "ARXIV"]),
  externalId: z.string(),
  url: z.string().url(),
  title: z.string(),
  titleHr: z.string().optional(),
  occurredAt: z.date(),
  impactLevel: z.enum(["BREAKING", "HIGH", "MEDIUM", "LOW"]),
  sourceCount: z.number(),
  topics: z.array(z.string()),
});

export type NormalizedEvent = z.infer<typeof NormalizedEventSchema>;

// Impact level heuristics
export function calculateImpactLevel(item: RawFeedItem): NormalizedEvent["impactLevel"] {
  const score = item.score ?? 0;
  if (score > 500) return "BREAKING";
  if (score > 200) return "HIGH";
  if (score > 50) return "MEDIUM";
  return "LOW";
}

// Topic extraction heuristics
export function extractTopics(item: RawFeedItem): string[] {
  const title = item.title.toLowerCase();
  const topics: string[] = [];

  const keywords: Record<string, string> = {
    openai: "OpenAI",
    gpt: "GPT",
    anthropic: "Anthropic",
    claude: "Claude",
    google: "Google",
    deepmind: "DeepMind",
    meta: "Meta",
    llama: "Llama",
    mistral: "Mistral",
    nvidia: "NVIDIA",
    transformer: "Transformers",
    "machine learning": "ML",
    "deep learning": "Deep Learning",
    benchmark: "Benchmark",
  };

  for (const [keyword, topic] of Object.entries(keywords)) {
    if (title.includes(keyword)) {
      topics.push(topic);
    }
  }

  return topics.slice(0, 5);
}
```

### Step 2: Export from shared

```typescript
// packages/shared/src/index.ts
export * from "./schemas/artifacts";
export * from "./graph-safety";
export * from "./types/feeds";
```

### Step 3: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(shared): add feed types and normalization utilities`

---

## Task 3: HN Feed Service

**Files:**
- Create: `packages/trpc/src/services/hn-feed.ts`
- Modify: `packages/trpc/src/routers/events.ts`

### Step 1: Create HN feed service

```typescript
// packages/trpc/src/services/hn-feed.ts
import {
  RawFeedItem,
  NormalizedEvent,
  calculateImpactLevel,
  extractTopics
} from "@genai/shared";

const HN_API = "https://hacker-news.firebaseio.com/v0";

interface HNItem {
  id: number;
  title?: string;
  url?: string;
  by?: string;
  time?: number;
  score?: number;
  descendants?: number;
  type?: string;
}

async function fetchItem(id: number): Promise<HNItem | null> {
  try {
    const res = await fetch(`${HN_API}/item/${id}.json`);
    if (!res.ok) return null;
    return res.json();
  } catch {
    return null;
  }
}

export async function fetchHNTopStories(limit = 30): Promise<NormalizedEvent[]> {
  try {
    // Get top story IDs
    const res = await fetch(`${HN_API}/topstories.json`);
    if (!res.ok) return [];

    const ids: number[] = await res.json();
    const topIds = ids.slice(0, limit);

    // Fetch items in parallel
    const items = await Promise.all(topIds.map(fetchItem));

    // Filter AI-related stories and normalize
    const aiKeywords = [
      "ai", "gpt", "llm", "openai", "anthropic", "claude", "gemini",
      "machine learning", "deep learning", "neural", "transformer",
      "chatgpt", "copilot", "mistral", "llama", "deepmind"
    ];

    const events: NormalizedEvent[] = [];

    for (const item of items) {
      if (!item || !item.title || item.type !== "story") continue;

      const titleLower = item.title.toLowerCase();
      const isAIRelated = aiKeywords.some((kw) => titleLower.includes(kw));
      if (!isAIRelated) continue;

      const rawItem: RawFeedItem = {
        sourceType: "HN",
        externalId: String(item.id),
        url: item.url || `https://news.ycombinator.com/item?id=${item.id}`,
        title: item.title,
        author: item.by,
        publishedAt: new Date((item.time || 0) * 1000),
        score: item.score,
        commentCount: item.descendants,
      };

      events.push({
        id: `hn-${item.id}`,
        sourceType: "HN",
        externalId: String(item.id),
        url: rawItem.url,
        title: item.title,
        occurredAt: rawItem.publishedAt,
        impactLevel: calculateImpactLevel(rawItem),
        sourceCount: 1,
        topics: extractTopics(rawItem),
      });
    }

    return events;
  } catch (error) {
    console.error("HN feed error:", error);
    return [];
  }
}
```

### Step 2: Integrate into events router

Update `packages/trpc/src/routers/events.ts` to include HN feed results.

### Step 3: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(feeds): add HN feed service with AI filtering`

---

## Task 4: GitHub Feed Service

**Files:**
- Create: `packages/trpc/src/services/github-feed.ts`

### Step 1: Create GitHub feed service

```typescript
// packages/trpc/src/services/github-feed.ts
import {
  RawFeedItem,
  NormalizedEvent,
  calculateImpactLevel,
  extractTopics
} from "@genai/shared";

const GITHUB_API = "https://api.github.com";

interface GitHubRepo {
  id: number;
  full_name: string;
  name: string;
  description: string | null;
  html_url: string;
  stargazers_count: number;
  pushed_at: string;
  owner: { login: string };
  topics: string[];
}

export async function fetchGitHubTrending(): Promise<NormalizedEvent[]> {
  try {
    // Search for AI/ML repos updated in last 7 days with high stars
    const date = new Date();
    date.setDate(date.getDate() - 7);
    const dateStr = date.toISOString().split("T")[0];

    const query = encodeURIComponent(
      `topic:machine-learning OR topic:deep-learning OR topic:llm OR topic:gpt pushed:>${dateStr} stars:>100`
    );

    const res = await fetch(
      `${GITHUB_API}/search/repositories?q=${query}&sort=stars&order=desc&per_page=20`,
      {
        headers: {
          Accept: "application/vnd.github.v3+json",
          // Note: Add GITHUB_TOKEN for higher rate limits
        },
      }
    );

    if (!res.ok) return [];

    const data = await res.json();
    const repos: GitHubRepo[] = data.items || [];

    const events: NormalizedEvent[] = repos.map((repo) => {
      const rawItem: RawFeedItem = {
        sourceType: "GITHUB",
        externalId: String(repo.id),
        url: repo.html_url,
        title: `${repo.full_name}: ${repo.description || repo.name}`,
        author: repo.owner.login,
        publishedAt: new Date(repo.pushed_at),
        score: repo.stargazers_count,
        tags: repo.topics,
      };

      return {
        id: `gh-${repo.id}`,
        sourceType: "GITHUB" as const,
        externalId: String(repo.id),
        url: repo.html_url,
        title: rawItem.title,
        occurredAt: rawItem.publishedAt,
        impactLevel: calculateImpactLevel(rawItem),
        sourceCount: 1,
        topics: repo.topics.slice(0, 5).length > 0
          ? repo.topics.slice(0, 5)
          : extractTopics(rawItem),
      };
    });

    return events;
  } catch (error) {
    console.error("GitHub feed error:", error);
    return [];
  }
}
```

### Step 2: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(feeds): add GitHub trending feed service`

---

## Task 5: Papers Feed Service (arXiv)

**Files:**
- Create: `packages/trpc/src/services/arxiv-feed.ts`

### Step 1: Create arXiv feed service

```typescript
// packages/trpc/src/services/arxiv-feed.ts
import {
  NormalizedEvent,
  extractTopics
} from "@genai/shared";

const ARXIV_API = "http://export.arxiv.org/api/query";

interface ArxivEntry {
  id: string;
  title: string;
  summary: string;
  published: string;
  authors: { name: string }[];
  links: { href: string; type?: string }[];
}

function parseArxivXML(xml: string): ArxivEntry[] {
  // Simple XML parsing for arXiv feed
  const entries: ArxivEntry[] = [];
  const entryMatches = xml.match(/<entry>[\s\S]*?<\/entry>/g) || [];

  for (const entry of entryMatches) {
    const id = entry.match(/<id>(.*?)<\/id>/)?.[1] || "";
    const title = entry.match(/<title>([\s\S]*?)<\/title>/)?.[1]?.replace(/\s+/g, " ").trim() || "";
    const summary = entry.match(/<summary>([\s\S]*?)<\/summary>/)?.[1]?.replace(/\s+/g, " ").trim() || "";
    const published = entry.match(/<published>(.*?)<\/published>/)?.[1] || "";

    const authorMatches = entry.match(/<author>[\s\S]*?<name>(.*?)<\/name>[\s\S]*?<\/author>/g) || [];
    const authors = authorMatches.map((a) => ({
      name: a.match(/<name>(.*?)<\/name>/)?.[1] || "",
    }));

    const linkMatch = entry.match(/<link[^>]*href="([^"]*)"[^>]*type="text\/html"/);
    const pdfLink = entry.match(/<link[^>]*href="([^"]*)"[^>]*title="pdf"/);

    entries.push({
      id,
      title,
      summary,
      published,
      authors,
      links: [
        { href: linkMatch?.[1] || id, type: "text/html" },
        ...(pdfLink ? [{ href: pdfLink[1], type: "application/pdf" }] : []),
      ],
    });
  }

  return entries;
}

export async function fetchArxivPapers(): Promise<NormalizedEvent[]> {
  try {
    // Search for recent AI/ML papers
    const categories = "cat:cs.AI+OR+cat:cs.LG+OR+cat:cs.CL";
    const url = `${ARXIV_API}?search_query=${categories}&sortBy=submittedDate&sortOrder=descending&max_results=20`;

    const res = await fetch(url);
    if (!res.ok) return [];

    const xml = await res.text();
    const entries = parseArxivXML(xml);

    const events: NormalizedEvent[] = entries.map((entry) => {
      const arxivId = entry.id.split("/abs/")[1] || entry.id;

      return {
        id: `arxiv-${arxivId}`,
        sourceType: "ARXIV" as const,
        externalId: arxivId,
        url: entry.links[0]?.href || entry.id,
        title: entry.title,
        occurredAt: new Date(entry.published),
        impactLevel: "MEDIUM" as const, // Papers default to MEDIUM
        sourceCount: 1,
        topics: extractTopics({
          sourceType: "ARXIV",
          externalId: arxivId,
          url: entry.id,
          title: entry.title,
          publishedAt: new Date(entry.published)
        }),
      };
    });

    return events;
  } catch (error) {
    console.error("arXiv feed error:", error);
    return [];
  }
}
```

### Step 2: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(feeds): add arXiv papers feed service`

---

## Task 6: Unified Events Router with Feeds

**Files:**
- Modify: `packages/trpc/src/routers/events.ts`

### Step 1: Update events router to aggregate feeds

```typescript
// packages/trpc/src/routers/events.ts
import { z } from "zod";
import { router, publicProcedure } from "../trpc";
import { fetchHNTopStories } from "../services/hn-feed";
import { fetchGitHubTrending } from "../services/github-feed";
import { fetchArxivPapers } from "../services/arxiv-feed";
import type { NormalizedEvent } from "@genai/shared";

const ImpactLevel = z.enum(["BREAKING", "HIGH", "MEDIUM", "LOW"]);

// Cache for feed results (simple in-memory, 5 min TTL)
let feedCache: { events: NormalizedEvent[]; timestamp: number } | null = null;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

async function getAggregatedEvents(): Promise<NormalizedEvent[]> {
  const now = Date.now();

  if (feedCache && now - feedCache.timestamp < CACHE_TTL) {
    return feedCache.events;
  }

  // Fetch all feeds in parallel
  const [hnEvents, ghEvents, arxivEvents] = await Promise.all([
    fetchHNTopStories(30),
    fetchGitHubTrending(),
    fetchArxivPapers(),
  ]);

  // Combine and sort by date
  const allEvents = [...hnEvents, ...ghEvents, ...arxivEvents];
  allEvents.sort((a, b) => b.occurredAt.getTime() - a.occurredAt.getTime());

  feedCache = { events: allEvents, timestamp: now };
  return allEvents;
}

export const eventsRouter = router({
  list: publicProcedure
    .input(
      z.object({
        cursor: z.string().optional(),
        limit: z.number().min(1).max(100).default(20),
        sourceType: z.enum(["HN", "GITHUB", "ARXIV"]).optional(),
        impactLevel: ImpactLevel.optional(),
        beforeTime: z.date().optional(),
      })
    )
    .query(async ({ input }) => {
      let items = await getAggregatedEvents();

      // Filter by source type
      if (input.sourceType) {
        items = items.filter((e) => e.sourceType === input.sourceType);
      }

      // Filter by time
      if (input.beforeTime) {
        items = items.filter(
          (e) => e.occurredAt.getTime() <= input.beforeTime!.getTime()
        );
      }

      // Filter by impact
      if (input.impactLevel) {
        items = items.filter((e) => e.impactLevel === input.impactLevel);
      }

      // Apply limit
      items = items.slice(0, input.limit);

      return {
        items,
        nextCursor: null as string | null,
      };
    }),

  byId: publicProcedure.input(z.string()).query(async ({ input }) => {
    const events = await getAggregatedEvents();
    return events.find((e) => e.id === input) ?? null;
  }),

  search: publicProcedure
    .input(
      z.object({
        query: z.string().min(1),
        limit: z.number().min(1).max(50).default(10),
      })
    )
    .query(async ({ input }) => {
      const events = await getAggregatedEvents();
      const q = input.query.toLowerCase();

      return events
        .filter(
          (e) =>
            e.title.toLowerCase().includes(q) ||
            e.topics.some((t) => t.toLowerCase().includes(q))
        )
        .slice(0, input.limit);
    }),
});
```

### Step 2: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(events): aggregate HN, GitHub, arXiv feeds with caching`

---

## Task 7: Update Observatory UI for Real Data

**Files:**
- Modify: `apps/web/src/app/observatory/page.tsx`

### Step 1: Update Observatory to use source-based lanes

```typescript
// apps/web/src/app/observatory/page.tsx
"use client";

import { useState, useMemo } from "react";
import { Lane } from "@/components/lane";
import { EventCard } from "@/components/event-card";
import { trpc } from "@/trpc";

export default function ObservatoryPage() {
  const [selectedEventId, setSelectedEventId] = useState<string | null>(null);

  const { data: eventsData, isLoading } = trpc.events.list.useQuery({
    limit: 100,
  });

  const events = eventsData?.items ?? [];

  // Split by source type
  const hnEvents = useMemo(
    () => events.filter((e) => e.sourceType === "HN"),
    [events]
  );
  const ghEvents = useMemo(
    () => events.filter((e) => e.sourceType === "GITHUB"),
    [events]
  );
  const arxivEvents = useMemo(
    () => events.filter((e) => e.sourceType === "ARXIV"),
    [events]
  );

  const renderEventCard = (event: (typeof events)[0]) => (
    <EventCard
      key={event.id}
      id={event.id}
      title={event.title}
      titleHr={event.titleHr}
      occurredAt={event.occurredAt}
      impactLevel={event.impactLevel}
      sourceCount={event.sourceCount}
      topics={event.topics}
      isSelected={selectedEventId === event.id}
      onClick={() => {
        setSelectedEventId(event.id);
        console.log("Selected event:", event.id, event.url);
      }}
    />
  );

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 h-full">
      <Lane
        title="Hacker News"
        icon={<span className="text-orange-500">üî∂</span>}
        count={hnEvents.length}
        isLoading={isLoading}
      >
        {hnEvents.length > 0 ? (
          hnEvents.map(renderEventCard)
        ) : (
          <p className="text-muted-foreground text-sm p-2">
            Nema HN vijesti
          </p>
        )}
      </Lane>

      <Lane
        title="GitHub"
        icon={<span>üêô</span>}
        count={ghEvents.length}
        isLoading={isLoading}
      >
        {ghEvents.length > 0 ? (
          ghEvents.map(renderEventCard)
        ) : (
          <p className="text-muted-foreground text-sm p-2">
            Nema GitHub projekata
          </p>
        )}
      </Lane>

      <Lane
        title="Radovi"
        icon={<span>üìÑ</span>}
        count={arxivEvents.length}
        isLoading={isLoading}
      >
        {arxivEvents.length > 0 ? (
          arxivEvents.map(renderEventCard)
        ) : (
          <p className="text-muted-foreground text-sm p-2">
            Nema radova
          </p>
        )}
      </Lane>
    </div>
  );
}
```

### Step 2: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(observatory): display real HN, GitHub, arXiv feeds in lanes`

---

## Task 8: Build Verification + Push

### Step 1: Full verification

```bash
pnpm build
pnpm typecheck
pnpm lint
```

### Step 2: Commit and push

```bash
git push origin main
```

### Step 3: Update ROADMAP.md

Mark Sprint 0.2 items as complete.

---

## Completion Report Template

After each task, report:

```
Files created:
Files modified:
Tests added:
pnpm build: PASS/FAIL
pnpm typecheck: PASS/FAIL
pnpm lint: PASS/FAIL
```

---

## Sprint 0.2 Exit Gate

- [ ] Searching "openai" shows results
- [ ] HN events appear in HN lane
- [ ] GitHub repos appear in GitHub lane
- [ ] arXiv papers appear in Papers lane
- [ ] Clicking event logs ID to console
- [ ] Build passes
- [ ] Typecheck passes
