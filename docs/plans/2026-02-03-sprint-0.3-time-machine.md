# Sprint 0.3: Time Machine Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Make the Time Machine scrubber functional - the flagship "holy crap" UX that makes users feel like they're time-traveling through AI news.

**Architecture:** Scrubber value converts to timestamp, passed to tRPC query. Events fade out/in based on their occurredAt vs scrubber time. Catch-up count calculated from actual filtered events.

**Tech Stack:** Next.js 15, tRPC, React state, CSS transitions, existing keyboard hook

---

## Sprint Scope

**IN SCOPE:**
- Scrubber UI functional (already exists, needs wiring)
- Time filter wired to tRPC query
- Catch-up count calculation (real count from events)
- Animation on time change (fade transitions)
- Keyboard navigation for time ([ ] and Shift+[ ])

**OUT OF SCOPE:**
- Context panel details (Sprint 0.4)
- Mobile layout (Sprint 0.4)
- Catch-up playback animation (future)
- Virtualization (Phase 3)

---

## Current State Analysis

**Already Implemented:**
- `TimeMachine` component (`apps/web/src/components/time-machine.tsx`)
- `ObservatoryShell` with scrubber state (`apps/web/src/components/layout/observatory-shell.tsx`)
- `useKeyboardNav` hook with time step callbacks (`apps/web/src/hooks/use-keyboard-nav.ts`)
- Events router with `beforeTime` filter (`packages/trpc/src/routers/events.ts`)
- Header displays TimeMachine component

**Missing:**
- Scrubber value → tRPC query connection
- Real catch-up count calculation
- Event card fade animation when filtered
- Keyboard navigation wired to scrubber

---

## Task 1: Create Time Context Provider

**Files:**
- Create: `apps/web/src/context/time-context.tsx`

### Implementation

Create a context to share time state across components:

```typescript
// apps/web/src/context/time-context.tsx
"use client";

import { createContext, useContext, useState, useCallback, useMemo, type ReactNode } from "react";

interface TimeContextValue {
  // Current scrubber value (0-100, 100 = now)
  scrubberValue: number;
  setScrubberValue: (value: number) => void;

  // Computed timestamp from scrubber
  targetTimestamp: Date;

  // Time range (7 days by default)
  rangeMs: number;

  // Is viewing the past?
  isInPast: boolean;

  // Step functions for keyboard nav
  stepBack: () => void;      // 1 hour back
  stepForward: () => void;   // 1 hour forward
  dayBack: () => void;       // 1 day back
  dayForward: () => void;    // 1 day forward
  jumpToNow: () => void;     // Reset to now
}

const TimeContext = createContext<TimeContextValue | null>(null);

const RANGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days
const HOUR_STEP = (1 / (7 * 24)) * 100;   // 1 hour as percentage of 7 days
const DAY_STEP = (1 / 7) * 100;           // 1 day as percentage of 7 days

export function TimeProvider({ children }: { children: ReactNode }) {
  const [scrubberValue, setScrubberValue] = useState(100);

  const targetTimestamp = useMemo(() => {
    const now = Date.now();
    const offset = RANGE_MS * (1 - scrubberValue / 100);
    return new Date(now - offset);
  }, [scrubberValue]);

  const isInPast = scrubberValue < 100;

  const stepBack = useCallback(() => {
    setScrubberValue((v) => Math.max(0, v - HOUR_STEP));
  }, []);

  const stepForward = useCallback(() => {
    setScrubberValue((v) => Math.min(100, v + HOUR_STEP));
  }, []);

  const dayBack = useCallback(() => {
    setScrubberValue((v) => Math.max(0, v - DAY_STEP));
  }, []);

  const dayForward = useCallback(() => {
    setScrubberValue((v) => Math.min(100, v + DAY_STEP));
  }, []);

  const jumpToNow = useCallback(() => {
    setScrubberValue(100);
  }, []);

  const value = useMemo(
    () => ({
      scrubberValue,
      setScrubberValue,
      targetTimestamp,
      rangeMs: RANGE_MS,
      isInPast,
      stepBack,
      stepForward,
      dayBack,
      dayForward,
      jumpToNow,
    }),
    [scrubberValue, targetTimestamp, isInPast, stepBack, stepForward, dayBack, dayForward, jumpToNow]
  );

  return <TimeContext.Provider value={value}>{children}</TimeContext.Provider>;
}

export function useTime() {
  const context = useContext(TimeContext);
  if (!context) {
    throw new Error("useTime must be used within a TimeProvider");
  }
  return context;
}
```

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): add time context provider for scrubber state`

---

## Task 2: Wire Time Context to Observatory

**Files:**
- Modify: `apps/web/src/app/observatory/layout.tsx`
- Modify: `apps/web/src/components/layout/observatory-shell.tsx`
- Modify: `apps/web/src/components/layout/header.tsx`

### Step 1: Add TimeProvider to layout

```typescript
// apps/web/src/app/observatory/layout.tsx
import { TimeProvider } from "@/context/time-context";

export default function ObservatoryLayout({ children }: { children: React.ReactNode }) {
  return (
    <TimeProvider>
      {/* existing shell */}
    </TimeProvider>
  );
}
```

### Step 2: Update ObservatoryShell to use context

Remove local scrubber state, use context instead.

### Step 3: Update Header to use context

Connect TimeMachine component to context.

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): wire time context to observatory shell`

---

## Task 3: Connect Time Filter to Events Query

**Files:**
- Modify: `apps/web/src/app/observatory/page.tsx`

### Implementation

Update the events query to use the time context:

```typescript
// apps/web/src/app/observatory/page.tsx
"use client";

import { useState, useMemo } from "react";
import { Lane } from "@/components/lane";
import { EventCard } from "@/components/event-card";
import { trpc } from "@/trpc";
import { useTime } from "@/context/time-context";

export default function ObservatoryPage() {
  const [selectedEventId, setSelectedEventId] = useState<string | null>(null);
  const { targetTimestamp, isInPast } = useTime();

  // Pass beforeTime only when viewing the past
  const { data: eventsData, isLoading } = trpc.events.list.useQuery({
    limit: 100,
    beforeTime: isInPast ? targetTimestamp : undefined,
  });

  const events = eventsData?.items ?? [];

  // ... rest of component
}
```

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): connect time filter to events query`

---

## Task 4: Calculate Real Catch-Up Count

**Files:**
- Modify: `apps/web/src/components/time-machine.tsx`
- Modify: `apps/web/src/context/time-context.tsx`

### Implementation

Add a query for total events count and calculate the difference:

```typescript
// In time-context.tsx or observatory page
// Query all events (no time filter) and filtered events
// catchUpCount = allEvents.length - filteredEvents.length

// Or simpler: pass events counts as props to TimeMachine
```

Update TimeMachine to show real count:

```typescript
// apps/web/src/components/time-machine.tsx
interface TimeMachineProps {
  value: number;
  onChange: (value: number) => void;
  totalEventCount: number;
  filteredEventCount: number;
}

// catchUpCount = totalEventCount - filteredEventCount
```

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): calculate real catch-up count from events`

---

## Task 5: Add Event Card Fade Animation

**Files:**
- Modify: `apps/web/src/components/event-card.tsx`
- Modify: `apps/web/src/app/observatory/page.tsx`

### Implementation

Add CSS transitions for smooth fade-in/out:

```typescript
// apps/web/src/components/event-card.tsx
interface EventCardProps {
  // ... existing props
  isFiltered?: boolean;  // true if event would be filtered by time
}

// Add transition classes
const baseClasses = cn(
  "transition-all duration-300 ease-in-out",
  isFiltered && "opacity-40 scale-95"
);
```

Alternative: Use layout animation with React Transition Group or Framer Motion for smoother list animations.

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): add fade animation to event cards on time change`

---

## Task 6: Wire Keyboard Navigation

**Files:**
- Modify: `apps/web/src/app/observatory/page.tsx` (or layout)

### Implementation

Connect the keyboard hook to time context:

```typescript
// apps/web/src/app/observatory/page.tsx or layout
import { useKeyboardNav } from "@/hooks/use-keyboard-nav";
import { useTime } from "@/context/time-context";

// In component:
const { stepBack, stepForward, dayBack, dayForward } = useTime();

useKeyboardNav({
  onNext: () => {/* event navigation */},
  onPrev: () => {/* event navigation */},
  onSelect: () => {/* select event */},
  onStepBack: stepBack,
  onStepForward: stepForward,
  onDayBack: dayBack,
  onDayForward: dayForward,
});
```

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): wire keyboard navigation to time scrubber`

---

## Task 7: Add Time Indicator to Header

**Files:**
- Modify: `apps/web/src/components/time-machine.tsx`

### Implementation

Improve the visual feedback:

```typescript
// Show clear indication of current time state
<div className="flex items-center gap-4">
  {/* Current date/time display */}
  <div className={cn(
    "text-sm font-mono",
    isInPast ? "text-amber-500" : "text-muted-foreground"
  )}>
    {isInPast ? (
      <>
        <Clock className="inline w-4 h-4 mr-1" />
        {targetDate.toLocaleDateString("hr-HR", {
          day: "numeric",
          month: "short",
          hour: "2-digit",
          minute: "2-digit"
        })}
      </>
    ) : (
      "UŽIVO"
    )}
  </div>

  {/* Jump to now button when in past */}
  {isInPast && (
    <button
      onClick={jumpToNow}
      className="text-xs text-primary hover:underline"
    >
      ↗ Skoči na sada
    </button>
  )}
</div>
```

### Step: Verify and commit

Run: `pnpm build && pnpm typecheck`
Commit: `feat(time): enhance time indicator with live status and jump button`

---

## Task 8: Final Verification + Push

### Step 1: Full verification

```bash
pnpm build
pnpm typecheck
pnpm lint
```

### Step 2: Verify Sprint 0.3 exit gates

**Gate:** Dragging scrubber filters visible events

- [ ] Drag scrubber left → events disappear (filtered by time)
- [ ] Drag scrubber right → events reappear
- [ ] Keyboard [ → step back 1 hour
- [ ] Keyboard ] → step forward 1 hour
- [ ] Keyboard Shift+[ → step back 1 day
- [ ] Keyboard Shift+] → step forward 1 day
- [ ] Catch-up count shows real number of missed events
- [ ] Build passes
- [ ] Typecheck passes

### Step 3: Update ROADMAP.md

Mark Sprint 0.3 items as complete, Sprint 0.4 as NEXT.

### Step 4: Commit and push

```bash
git add .
git commit -m "docs: mark Sprint 0.3 complete"
git push origin main
```

---

## Sprint 0.3 Exit Gate

- [ ] Scrubber UI functional
- [ ] Time filter wired to tRPC query
- [ ] Catch-up count calculation (real count)
- [ ] Animation on time change
- [ ] Keyboard navigation working ([ ] Shift+[ Shift+])
- [ ] Build passes
- [ ] Typecheck passes

**Success:** Dragging scrubber filters visible events smoothly

---

## Technical Notes

### Time Calculation

```
scrubberValue: 0-100 (100 = now)
rangeMs: 7 * 24 * 60 * 60 * 1000 (7 days)

targetTimestamp = now - (rangeMs * (1 - scrubberValue/100))

Examples:
- scrubberValue = 100 → now
- scrubberValue = 50  → 3.5 days ago
- scrubberValue = 0   → 7 days ago
```

### Keyboard Step Sizes

```
HOUR_STEP = (1 / (7 * 24)) * 100 ≈ 0.595%
DAY_STEP  = (1 / 7) * 100       ≈ 14.29%
```

### Performance Considerations

- Events query refetches on targetTimestamp change
- Use debounce on scrubber drag to avoid excessive queries
- Consider optimistic UI updates for smoother feel

---

## Files Summary

### To Create
- `apps/web/src/context/time-context.tsx`

### To Modify
- `apps/web/src/app/observatory/layout.tsx`
- `apps/web/src/app/observatory/page.tsx`
- `apps/web/src/components/layout/observatory-shell.tsx`
- `apps/web/src/components/layout/header.tsx`
- `apps/web/src/components/time-machine.tsx`
- `apps/web/src/components/event-card.tsx`
- `docs/ROADMAP.md`
